<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <title>shader/370</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #startOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            cursor: pointer;
        }
        #startText {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
            padding: 20px;
            border: 2px solid white;
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        #startText:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
        #copyright {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            color: rgba(255, 255, 255, 0.3);
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
        #effectNumber {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            color: rgba(255, 255, 255, 0.3);
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        #effectName {
            color: rgba(255, 255, 255, 0.3);
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        #skipButton {
            background: #2196F3;
        }
        #skipButton:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="startOverlay">
        <div id="startText">Click anywhere to start the experience</div>
    </div>
    <div id="controls">
        <button id="muteButton">üîä Mute</button>
        <button id="skipButton">‚è≠Ô∏è Skip Track</button>
        <div id="currentTrack" style="margin-top: 5px; font-size: 14px;"></div>
    </div>
    <div id="effectNumber">
        <span id="effectNumberText"></span>
        <span id="effectName"></span>
    </div>
    <div id="copyright">(c) hot dog studios</div>
    
    <script>
        // (c) by moshix and hot dog studios
        // shader effect for MVS 3.8 httpd server
        // https://github.com/moshix/mvs38
        // v0.1 humble beginnings
        // 0.2 started adding effects  
        // 0.3 added more effects
        // 0.4 music!
        // 0.5 music controls
        // 0.6 ask user to click something to make music play
        // 0.7 added more effects
        // 0.8 remvoe effect counter
        
        const vertexShaderSrc = `
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
            vUv = position * 0.5 + 0.5;
            gl_Position = vec4(position, 0.0, 1.0);
        }
        `;

        const shaderEffects = [
            // =========================================================
            // SHADER EFFECTS INDEX
            // =========================================================
            // Effect #1:  Current flowing pattern             (line 123)
            // Effect #2:  Cosmic Nebula                       (line 156)
            // Effect #3:  Dynamic Mandala                     (line 205)
            // Effect #4:  Electric Field                      (line 274)
            // Effect #5:  Wave interference with red theme    (line 337)
            // Effect #6:  Kaleidoscope with rainbow theme     (line 375)
            // Effect #7:  Dynamic Geometric Pattern           (line 419)
            // Effect #8:  Quantum Flux                        (line 479)
            // Effect #9:  Liquid Crystal                      (line 558)
            // Effect #10: Aurora Dreams                       (line 627)
            // Effect #11: Neon Cityscape                      (line 696)
            // Effect #12: Ocean Depths                        (line 829)
            // Effect #13: Burning Mandelbrot                  (line 954)
            // Effect #14: Julia Spirals                       (line 1037)
            // Effect #15: Water Caustics                      (line 1127)
            // =========================================================
            
            // Effect 1: Current flowing pattern
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                float f = cos(a * 3.0) * sin(r * 10.0 - t * 2.0);
                f += sin(p.x * 8.0 + t) * cos(p.y * 8.0 - t);
                f += sin(r * 5.0 - t * 1.5) * cos(a * 2.0);
                
                vec3 hsv = vec3(f * 0.5 + 0.5 + t * 0.1, 0.8, 0.5 + f * 0.5);
                vec3 color = hsv2rgb(hsv);
                
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.5;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 2: New effect - Cosmic Nebula
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create nebula-like effect
                float n = noise(p + t * 0.1);
                float f = sin(r * 10.0 - t * 2.0) * cos(a * 5.0 + t);
                f += sin(p.x * 8.0 + t) * cos(p.y * 8.0 - t);
                f += noise(p * 2.0 + t * 0.2) * 0.5;
                
                // Create multiple layers of color
                vec3 color1 = hsv2rgb(vec3(0.6 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Blue
                vec3 color2 = hsv2rgb(vec3(0.8 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Purple
                vec3 color3 = hsv2rgb(vec3(0.9 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Pink
                
                vec3 color = mix(color1, color2, sin(t * 0.5) * 0.5 + 0.5);
                color = mix(color, color3, cos(t * 0.7) * 0.5 + 0.5);
                
                // Add stars
                float stars = pow(noise(p * 50.0), 20.0);
                color += vec3(1.0) * stars * 0.5;
                
                // Add glow
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 3: New effect - Dynamic Mandala
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float pattern(vec2 p, float scale) {
                float s = scale;
                vec2 q = p * s;
                float d = length(fract(q) - 0.5);
                return smoothstep(0.0, 0.1, d);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create dynamic mandala pattern
                float scale = 8.0;
                float rotation = t * 0.5;
                float petals = 12.0;
                
                // Rotate and scale coordinates
                vec2 q = p;
                float c = cos(rotation), s = sin(rotation);
                q = mat2(c, -s, s, c) * q;
                q *= scale;
                
                // Create base pattern
                float f = pattern(q, 1.0);
                
                // Add petal effect
                float petal = sin(a * petals + r * 10.0 - t * 3.0);
                f += petal * 0.3;
                
                // Add spiral effect
                float spiral = sin(a * 8.0 + r * 15.0 - t * 2.0);
                f += spiral * 0.2;
                
                // Create color based on pattern
                vec3 hsv = vec3(
                    fract(0.5 + f * 0.2 + t * 0.1),  // Magenta to cyan hue
                    0.8,                               // Full saturation
                    0.3 + f * 0.7                     // Value based on pattern
                );
                
                vec3 color = hsv2rgb(hsv);
                
                // Add glow effect
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.8, 0.2, 0.8) * glow * 0.3;
                
                // Add highlights
                float highlight = smoothstep(0.0, 0.1, f);
                color += vec3(1.0) * highlight * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 4: New effect - Electric Field
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Create electric field effect
                float field = 0.0;
                
                // Add multiple electric charges
                for(float i = 0.0; i < 4.0; i++) {
                    float angle = i * 1.5708 + t * 0.5;
                    vec2 charge = vec2(cos(angle), sin(angle)) * 0.5;
                    
                    // Calculate electric field
                    vec2 diff = p - charge;
                    float dist = length(diff);
                    float strength = 1.0 / (dist * dist);
                    
                    // Add field lines
                    float angle2 = atan(diff.y, diff.x);
                    field += sin(angle2 * 20.0 + dist * 30.0 - t * 3.0) * strength;
                }
                
                // Add noise for texture
                float n = noise(p * 5.0 + t * 0.2);
                field += n * 0.2;
                
                // Create color based on field strength
                vec3 hsv = vec3(
                    0.2 + field * 0.1,  // Yellow to green hue
                    0.8,                 // Full saturation
                    0.2 + field * 0.8    // Value based on field strength
                );
                
                vec3 color = hsv2rgb(hsv);
                
                // Add electric arcs
                float arc = smoothstep(0.0, 0.1, abs(field - 0.5));
                color += vec3(1.0, 0.8, 0.0) * arc * 0.5;
                
                // Add glow
                float glow = smoothstep(0.0, 1.0, 1.0 - length(p));
                color += vec3(0.0, 0.8, 0.2) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 5: Wave interference with red theme
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float d1 = length(p - vec2(-0.5, -0.5));
                float d2 = length(p - vec2(0.5, 0.5));
                float d3 = length(p - vec2(0.0, 0.5));
                
                float f = sin(d1 * 15.0 - t * 3.0) + 
                         sin(d2 * 15.0 - t * 3.0 + 2.094) + 
                         sin(d3 * 15.0 - t * 3.0 + 4.188);
                
                // Red and orange theme
                vec3 hsv = vec3(
                    0.0 + f * 0.1,  // Red to orange hue
                    0.8,             // Full saturation
                    0.5 + f * 0.5    // Value varies with pattern
                );
                
                vec3 color = hsv2rgb(hsv);
                color = pow(color, vec3(0.8));
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 6: Kaleidoscope with rainbow theme
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                float segments = 8.0;
                float angle = 2.0 * 3.14159 / segments;
                float segment = floor(a / angle);
                float segmentAngle = mod(a, angle);
                
                float f = sin(segmentAngle * 15.0 + r * 20.0 - t * 3.0);
                f += cos(segment * 3.0 + t * 2.0);
                f += sin(r * 10.0 - t * 1.5);
                
                // Rainbow theme
                vec3 hsv = vec3(
                    fract(segment / segments + t * 0.1),  // Rainbow hue
                    0.8,                                  // Full saturation
                    0.5 + f * 0.5                        // Value varies with pattern
                );
                
                vec3 color = hsv2rgb(hsv);
                
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(1.0, 1.0, 1.0) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 7: Dynamic Geometric Pattern
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float pattern(vec2 p, float scale) {
                vec2 q = p * scale;
                float d = length(fract(q) - 0.5);
                return smoothstep(0.0, 0.1, d);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create rotating geometric pattern
                float rotation = t * 0.5;
                float c = cos(rotation), s = sin(rotation);
                vec2 q = mat2(c, -s, s, c) * p;
                
                // Create multiple layers of patterns
                float f = pattern(q, 4.0);
                f += pattern(q * 1.5, 6.0) * 0.5;
                f += pattern(q * 2.0, 8.0) * 0.25;
                
                // Add wave effect
                float wave = sin(a * 8.0 + r * 10.0 - t * 3.0);
                f += wave * 0.2;
                
                // Create smooth color transitions
                vec3 color1 = hsv2rgb(vec3(0.6 + f * 0.2, 0.8, 0.5));  // Blue
                vec3 color2 = hsv2rgb(vec3(0.8 + f * 0.2, 0.8, 0.5));  // Purple
                vec3 color3 = hsv2rgb(vec3(0.9 + f * 0.2, 0.8, 0.5));  // Pink
                
                // Mix colors based on position and time
                vec3 color = mix(color1, color2, sin(t * 0.5) * 0.5 + 0.5);
                color = mix(color, color3, cos(t * 0.7) * 0.5 + 0.5);
                
                // Add glow effect
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.3;
                
                // Add highlights
                float highlight = smoothstep(0.0, 0.1, f);
                color += vec3(1.0) * highlight * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 8: Quantum Flux - A hypnotic effect with layered, fractal-inspired patterns
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            float fractalnoise(vec2 p) {
                float n = 0.0;
                float amp = 1.0;
                float freq = 1.0;
                
                for(int i = 0; i < 6; i++) {
                    float noise = fract(sin(dot(p * freq, vec2(127.1, 311.7))) * 43758.5453);
                    n += noise * amp;
                    amp *= 0.5;
                    freq *= 2.0;
                }
                
                return n;
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Multiple layers of shifting, rotating patterns
                float time = t * 0.5;
                float rotationSpeed = 0.2;
                float zoomSpeed = 0.15;
                
                // First layer - rotating fractal noise
                float angle1 = time * rotationSpeed;
                float c1 = cos(angle1), s1 = sin(angle1);
                vec2 q1 = mat2(c1, -s1, s1, c1) * p;
                q1 *= 1.0 + sin(time * zoomSpeed) * 0.3;
                float n1 = fractalnoise(q1 * 3.0);
                
                // Second layer - contracting/expanding rings
                float rings = length(p) * 10.0 - time * 2.0;
                rings = abs(mod(rings, 2.0) - 1.0);
                rings = smoothstep(0.5, 0.8, rings);
                
                // Third layer - spiral waves
                float angle2 = atan(p.y, p.x);
                float spiral = sin(angle2 * 8.0 + length(p) * 15.0 - time * 3.0);
                
                // Combine layers with temporal variations
                float blend = sin(time * 0.3) * 0.5 + 0.5;
                float pattern = mix(n1, rings, blend * 0.7);
                pattern = mix(pattern, spiral, (1.0 - blend) * 0.5);
                
                // Create pulsating color gradients
                vec3 color1 = hsv2rgb(vec3(0.7 + time * 0.05, 0.8, 0.6)); // Blue-purple base
                vec3 color2 = hsv2rgb(vec3(0.9 + time * 0.05, 0.9, 0.7)); // Magenta-pink accent
                vec3 color3 = hsv2rgb(vec3(0.5 + time * 0.05, 0.7, 0.8)); // Cyan highlight
                
                // Mix colors based on pattern and oscillating functions
                vec3 color = mix(color1, color2, pattern);
                color = mix(color, color3, spiral * 0.5);
                
                // Add shimmering effect
                float shimmer = fractalnoise(p * 50.0 + time * 0.1);
                color += vec3(1.0) * shimmer * 0.1;
                
                // Vignette effect
                float vignette = 1.0 - length(p * 0.7);
                vignette = smoothstep(0.0, 0.8, vignette);
                color *= vignette * 1.5;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 9: Liquid Crystal - Beautiful fluid-like movement with prismatic colors
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            // Simplex noise function
            float hash21(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
            }
            
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                
                // Four corners
                float a = hash21(i);
                float b = hash21(i + vec2(1.0, 0.0));
                float c = hash21(i + vec2(0.0, 1.0));
                float d = hash21(i + vec2(1.0, 1.0));
                
                // Cubic Hermine curve
                vec2 u = f * f * (3.0 - 2.0 * f);
                
                // Mix 4 corners
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float time = t * 0.4;
                
                // Create multiple layers of noise at different scales and speeds
                float scale1 = 4.0 + sin(time * 0.2) * 2.0;
                float scale2 = 8.0 + cos(time * 0.1) * 4.0;
                float scale3 = 16.0;
                
                // Create rotation matrices for each layer
                float a1 = time * 0.1;
                float a2 = time * -0.05;
                mat2 rot1 = mat2(cos(a1), -sin(a1), sin(a1), cos(a1));
                mat2 rot2 = mat2(cos(a2), -sin(a2), sin(a2), cos(a2));
                
                // Generate noise layers
                float n1 = noise(p * scale1 * rot1);
                float n2 = noise(p * scale2 * rot2);
                float n3 = noise(p * scale3);
                
                // Create pattern by combining noise layers
                float pattern = n1 * 0.6 + n2 * 0.3 + n3 * 0.1;
                
                // Create sharp edges
                float edge = smoothstep(0.4, 0.5, pattern) * smoothstep(0.6, 0.5, pattern);
                
                // Create base color from pattern
                vec3 baseColor1 = hsv2rgb(vec3(0.55 + pattern * 0.1, 0.6, 0.6)); // Blue-purple range
                vec3 baseColor2 = hsv2rgb(vec3(0.95 + pattern * 0.1, 0.7, 0.7)); // Pink-red range
                vec3 baseColor = mix(baseColor1, baseColor2, 0.5 + 0.5 * sin(time * 0.2));
                
                // Create edge color
                vec3 edgeColor = hsv2rgb(vec3(0.6 + pattern * 0.2, 0.9, 0.9)); // Bright accent color
                
                // Combine colors
                vec3 color = mix(baseColor, edgeColor, edge);
                
                // Add light sources
                for (int i = 0; i < 3; i++) {
                    // Light position with circular motion
                    float angle = time * 0.5 + float(i) * 2.09;
                    float radius = 0.5 + 0.3 * sin(time * 0.2 + float(i));
                    vec2 lightPos = vec2(sin(angle), cos(angle)) * radius;
                    
                    // Light intensity with distance falloff
                    float dist = length(p - lightPos);
                    float intensity = 0.15 / (dist * dist + 0.01);
                    
                    // Add pulsing effect
                    intensity *= 0.8 + 0.2 * sin(time * 2.0 + float(i) * 2.0);
                    
                    // Add light to the color
                    color += vec3(1.0, 0.9, 0.8) * intensity;
                }
                
                // Add depth effect with dark areas
                float darkness = smoothstep(0.0, 0.5, length(p));
                color = mix(color, vec3(0.0, 0.02, 0.05), darkness * 0.5);
                
                // Add subtle bloom/glow
                float glow = smoothstep(0.5, 0.0, length(p));
                color += baseColor2 * glow * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 10: Aurora Dreams - Northern lights-inspired effect with organic flowing patterns
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create nebula-like effect
                float n = noise(p + t * 0.1);
                float f = sin(r * 10.0 - t * 2.0) * cos(a * 5.0 + t);
                f += sin(p.x * 8.0 + t) * cos(p.y * 8.0 - t);
                f += noise(p * 2.0 + t * 0.2) * 0.5;
                
                // Create multiple layers of color
                vec3 color1 = hsv2rgb(vec3(0.6 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Blue
                vec3 color2 = hsv2rgb(vec3(0.8 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Purple
                vec3 color3 = hsv2rgb(vec3(0.9 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Pink
                
                vec3 color = mix(color1, color2, sin(t * 0.5) * 0.5 + 0.5);
                color = mix(color, color3, cos(t * 0.7) * 0.5 + 0.5);
                
                // Add stars
                float stars = pow(noise(p * 50.0), 20.0);
                color += vec3(1.0) * stars * 0.5;
                
                // Add glow
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 11: Neon Cityscape - Bright neon lights with flickering effect
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float hash(float n) {
                return fract(sin(n) * 43758.5453123);
            }
            
            float noise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);
                float n = i.x + i.y * 57.0;
                return mix(
                    mix(hash(n), hash(n + 1.0), f.x),
                    mix(hash(n + 57.0), hash(n + 58.0), f.x),
                    f.y
                );
            }
            
            float rect(vec2 p, vec2 size) {
                vec2 d = abs(p) - size;
                return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float time = t * 0.3;
                
                // Create dark city background
                vec3 color = vec3(0.02, 0.02, 0.05); // Dark blue night
                
                // City skyline with buildings
                float skyline = 0.0;
                
                // Generate buildings
                for (int i = -10; i < 10; i++) {
                    // Building properties
                    float seed = float(i) * 10.0;
                    float height = 0.3 + 0.4 * hash(seed);
                    float width = 0.1 + 0.05 * hash(seed + 5.0);
                    float xPos = float(i) * 0.2 + 0.1 * hash(seed + 10.0);
                    
                    // Building rectangle
                    vec2 buildingPos = vec2(xPos, -0.5 + height * 0.5);
                    vec2 buildingSize = vec2(width * 0.5, height * 0.5);
                    float building = rect(p - buildingPos, buildingSize);
                    
                    // Add building to skyline
                    if (building < 0.0) {
                        skyline = 1.0;
                        
                        // Windows
                        vec2 windowUV = (p - buildingPos) / buildingSize;
                        vec2 windowGrid = fract(windowUV * vec2(5.0, 8.0));
                        float windowMask = step(0.3, windowGrid.x) * step(0.3, windowGrid.y);
                        
                        // Random lit windows
                        float lit = step(0.5, hash(floor(windowUV.x * 5.0) + 100.0 * floor(windowUV.y * 8.0) + time * 0.2));
                        
                        // Add windows to the color
                        vec3 windowColor = hsv2rgb(vec3(
                            0.6 * hash(seed), 
                            0.5 + 0.5 * hash(seed + 20.0), 
                            0.8 + 0.2 * hash(seed + 30.0)
                        ));
                        
                        // Flicker some windows
                        float flicker = 0.8 + 0.2 * sin(time * (5.0 + hash(seed) * 10.0));
                        
                        // Add the window lights
                        color += windowColor * windowMask * lit * flicker * 0.8;
                    }
                }
                
                // Ground plane with grid
                float ground = smoothstep(0.005, 0.0, abs(p.y + 0.5) - 0.005);
                color += vec3(0.1, 0.1, 0.2) * ground;
                
                // Add street grid
                float streetX = smoothstep(0.002, 0.0, abs(fract(p.x * 5.0) - 0.5) - 0.002) * step(-0.5, p.y);
                float streetY = smoothstep(0.002, 0.0, abs(fract(p.y * 5.0) - 0.5) - 0.002) * step(-0.5, p.y);
                color += vec3(0.1, 0.1, 0.3) * (streetX + streetY);
                
                // Add neon signs
                for (int i = 0; i < 8; i++) {
                    float seedSign = float(i) * 20.0;
                    
                    // Sign position and properties
                    float xSign = -0.8 + 1.6 * hash(seedSign);
                    float ySign = -0.3 + 0.6 * hash(seedSign + 10.0);
                    float sizeSign = 0.05 + 0.05 * hash(seedSign + 20.0);
                    
                    // Create neon sign shape
                    float signDist = length(p - vec2(xSign, ySign)) - sizeSign;
                    
                    // Sign color with time variation
                    vec3 signColor = hsv2rgb(vec3(
                        hash(seedSign + 30.0) + time * 0.05 * hash(seedSign + 40.0),
                        0.8,
                        0.9
                    ));
                    
                    // Neon glow effect
                    float glow = 0.003 / (signDist * signDist + 0.001);
                    
                    // Flickering effect for some signs
                    float signFlicker = hash(seedSign + 50.0) > 0.7 ?
                        0.7 + 0.3 * sin(time * (10.0 * hash(seedSign + 60.0))) :
                        1.0;
                    
                    // Add to final color
                    color += signColor * glow * signFlicker;
                }
                
                // Add flying cars (small moving lights)
                for (int i = 0; i < 5; i++) {
                    float seedCar = float(i) * 30.0;
                    
                    // Car movement
                    float carSpeed = 0.2 + 0.3 * hash(seedCar);
                    float xCar = fract(time * carSpeed + hash(seedCar)) * 2.0 - 1.0;
                    float yCar = -0.2 - 0.4 * hash(seedCar + 10.0);
                    
                    // Car lights (dual)
                    float carLight1 = 0.002 / length(p - vec2(xCar - 0.02, yCar));
                    float carLight2 = 0.002 / length(p - vec2(xCar + 0.02, yCar));
                    
                    // Car color
                    vec3 carColor = hsv2rgb(vec3(
                        hash(seedCar + 20.0),
                        0.6,
                        1.0
                    ));
                    
                    // Add to final color
                    color += carColor * (carLight1 + carLight2) * 0.5;
                }
                
                // Falling rain effect
                float rainAmount = 0.4;
                for (int i = 0; i < 70; i++) {
                    float seedRain = float(i) * 5.0;
                    
                    // Rain drop position
                    float xRain = hash(seedRain) * 2.0 - 1.0;
                    float yRain = fract(hash(seedRain + 10.0) - time * (1.0 + hash(seedRain + 20.0))) * 2.0 - 1.0;
                    
                    // Rain drop and trail
                    float rainDrop = smoothstep(0.005, 0.0, length(p - vec2(xRain, yRain)) - 0.001);
                    float rainTrail = smoothstep(0.004, 0.0, abs(p.x - xRain) - 0.001) * 
                                     smoothstep(0.1, 0.0, p.y - yRain) * 
                                     smoothstep(0.0, 0.1, p.y - yRain - 0.1);
                    
                    // Add blue-tinted rain
                    color += vec3(0.6, 0.7, 1.0) * (rainDrop + rainTrail * 0.5) * rainAmount;
                }
                
                // Add fog/haze
                float fog = smoothstep(-0.4, 0.8, p.y);
                color = mix(color, vec3(0.1, 0.1, 0.2), fog * 0.5);
                
                // Add bloom/glow to bright areas
                vec3 blur = color;
                for (int i = 0; i < 4; i++) {
                    float blurRadius = 0.01 * float(i+1);
                    blur += color * exp(-length(p) / blurRadius) * 0.1;
                }
                color = mix(color, blur, 0.5);
                
                // Vignette effect
                float vignette = 1.0 - length(uv * 0.7);
                vignette = smoothstep(0.0, 1.0, vignette);
                color *= vignette;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 12: Ocean Depths - Enhanced with bioluminescence and dynamic sea life
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            // Enhanced noise function for more organic patterns
            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                f = f * f * (3.0 - 2.0 * f);
                
                float a = fract(sin(dot(i, vec2(12.9898, 78.233))) * 43758.5453);
                float b = fract(sin(dot(i + vec2(1.0, 0.0), vec2(12.9898, 78.233))) * 43758.5453);
                float c = fract(sin(dot(i + vec2(0.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);
                float d = fract(sin(dot(i + vec2(1.0, 1.0), vec2(12.9898, 78.233))) * 43758.5453);
                
                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }
            
            // Jellyfish shape function
            float jellyfish(vec2 p, vec2 center, float size, float time) {
                vec2 pos = p - center;
                float angle = atan(pos.y, pos.x);
                float radius = length(pos);
                
                // Pulsating body
                float body = smoothstep(size, size * 0.9, radius);
                body *= 1.0 + 0.2 * sin(time * 2.0);
                
                // Tentacles
                float tentacles = 0.0;
                for(float i = 0.0; i < 8.0; i++) {
                    float angleOffset = i * 3.14159 * 2.0 / 8.0;
                    float wavyTentacle = sin(angle + angleOffset) * sin(radius * 10.0 - time * 3.0);
                    tentacles += smoothstep(0.1, 0.0, abs(wavyTentacle)) * smoothstep(size * 2.0, size, radius);
                }
                
                return body + tentacles * 0.3;
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                float time = t * 0.5;
                
                // Enhanced layered caustics
                float caustics = 0.0;
                for(float i = 1.0; i < 4.0; i++) {
                    vec2 pos = p * (5.0 * i) + vec2(time * i * 0.2, time * i * 0.1);
                    caustics += sin(pos.x) * sin(pos.y) * (0.5 / i);
                    
                    // Add rotated layer
                    float angle = time * 0.1 * i;
                    vec2 rotPos = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * pos;
                    caustics += sin(rotPos.x) * sin(rotPos.y) * (0.3 / i);
                }
                caustics = pow(caustics * 0.5 + 0.5, 2.0);
                
                // Multiple layers of water movement
                float waterNoise = 0.0;
                for(float i = 1.0; i < 5.0; i++) {
                    waterNoise += noise(p * (3.0 * i) + time * vec2(0.1, 0.2) * i) * (1.0 / i);
                }
                
                // Create depth gradient
                float depth = p.y * 0.5 + 0.5;
                vec3 waterColor = mix(
                    vec3(0.0, 0.2, 0.3), // Deep water
                    vec3(0.1, 0.4, 0.6), // Shallow water
                    depth
                );
                
                // Add caustics effect
                vec3 causticColor = mix(
                    vec3(0.2, 0.5, 0.7), // Blue caustics
                    vec3(0.4, 0.7, 1.0), // White-blue caustics
                    caustics
                );
                waterColor = mix(waterColor, causticColor, caustics * 0.5);
                
                // Add multiple jellyfish with different movements
                float jellies = 0.0;
                for(float i = 0.0; i < 3.0; i++) {
                    float jTime = time + i * 2.0;
                    vec2 jellyCenter = vec2(
                        sin(jTime * 0.5 + i * 2.0) * 0.5,
                        cos(jTime * 0.3 + i * 1.5) * 0.3 - 0.2
                    );
                    float size = 0.15 + 0.05 * sin(jTime + i);
                    jellies += jellyfish(p, jellyCenter, size, jTime);
                }
                
                // Bioluminescent glow for jellyfish
                vec3 jellyGlow = mix(
                    vec3(0.2, 0.4, 0.8), // Blue bioluminescence
                    vec3(0.3, 0.7, 1.0), // Bright blue-white
                    sin(time) * 0.5 + 0.5
                );
                waterColor = mix(waterColor, jellyGlow, jellies * 0.8);
                
                // Add floating particles
                float particles = 0.0;
                for(float i = 0.0; i < 10.0; i++) {
                    vec2 particlePos = vec2(
                        fract(sin(i * 234.5) * 543.21),
                        fract(cos(i * 123.4) * 432.15)
                    ) * 2.0 - 1.0;
                    particlePos += vec2(sin(time + i), cos(time * 0.5 + i)) * 0.3;
                    float particle = smoothstep(0.02, 0.0, length(p - particlePos));
                    particles += particle;
                }
                
                // Add particle glow with color variation
                vec3 particleColor = hsv2rgb(vec3(
                    0.5 + 0.1 * sin(time), // Varying hue
                    0.8,                    // High saturation
                    1.0                     // Full brightness
                ));
                waterColor += particleColor * particles * 0.5;
                
                // Enhanced volumetric light rays
                float rays = 0.0;
                for(float i = 0.0; i < 8.0; i++) {
                    float angle = i * 3.14159 * 2.0 / 8.0;
                    vec2 rayDir = vec2(sin(angle), cos(angle));
                    float ray = smoothstep(0.2, 0.0, abs(dot(normalize(p), rayDir)));
                    rays += ray * (0.5 + 0.5 * sin(time + i));
                }
                rays *= smoothstep(1.0, 0.0, length(p));
                
                // Add rays to final color
                waterColor += vec3(0.3, 0.5, 0.7) * rays * 0.3;
                
                // Add subtle color variations based on noise
                waterColor *= 0.8 + 0.2 * waterNoise;
                
                // Enhanced vignette effect
                float vignette = smoothstep(1.2, 0.5, length(p));
                waterColor *= vignette * 1.2;
                
                // Final color adjustments
                waterColor = pow(waterColor, vec3(0.8)); // Gamma correction
                
                gl_FragColor = vec4(waterColor, 1.0);
            }
            `,
            // Effect 13: Burning Mandelbrot - Deep zoom into seahorse valley
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            // Palette generator for rich color variation
            vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
                return a + b * cos(6.28318 * (c * t + d));
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Time-based animation parameters
                float time = t * 0.2; // Slower time progression
                float effectTime = mod(time, 30.0); // Full 30-second cycle
                
                // Deep zoom parameters
                // Starting at a point in seahorse valley (-0.743643887037158704752191506114774, 0.131825904205311970493132056385139)
                vec2 center = vec2(-0.743643887037158704752191506114774, 0.131825904205311970493132056385139);
                
                // Faster, more aggressive exponential zoom
                float zoom = pow(2.0, effectTime * 3.0); // Increased zoom speed from 2.0 to 3.0
                
                // Add slight rotation for more dynamic effect
                float angle = effectTime * 0.1; // Slower rotation
                mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                p = rot * p;
                
                // Calculate actual complex plane coordinates with zoom
                vec2 c = p / zoom + center;
                
                // Initialize Mandelbrot iteration
                vec2 z = vec2(0.0);
                float iteration = 0.0;
                float maxIterations = 1000.0; // Doubled for better detail at high zoom
                
                // Track the orbit for coloring
                vec2 orbit = vec2(0.0);
                
                // Main Mandelbrot loop with enhanced dynamic iteration count based on zoom
                float dynamicIterations = maxIterations * (1.0 + log(zoom) * 0.2); // Increased scaling factor from 0.1 to 0.2
                for (float i = 0.0; i < 1000.0; i++) { // Match loop limit with maxIterations
                    if (i >= dynamicIterations) break;
                    
                    // Store last orbit for trap coloring
                    orbit = z;
                    
                    // z = z^2 + c (in complex number math)
                    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                    
                    // Check if point escapes
                    if (length(z) > 2.0) {
                        iteration = i;
                        break;
                    }
                }
                
                // Create smooth coloring
                float smooth_iteration = iteration;
                if (iteration < dynamicIterations) {
                    // Enhanced smooth coloring formula
                    smooth_iteration = iteration + 1.0 - log2(log2(length(z))) + 4.0;
                }
                
                // Normalize and adjust for color mapping
                float normalized = smooth_iteration / dynamicIterations;
                
                // Create a burning color palette (oranges, reds, yellows)
                vec3 fire1 = palette(
                    normalized + effectTime * 0.1, // Slower color cycling
                    vec3(0.5, 0.5, 0.5),   // brightness
                    vec3(0.5, 0.5, 0.5),   // contrast
                    vec3(1.0, 1.0, 1.0),   // oscillation frequency
                    vec3(0.0, 0.33, 0.67)  // phase shift (creates fire colors)
                );
                
                // Create a second color palette for variation
                vec3 fire2 = palette(
                    normalized + effectTime * 0.05, // Slower color cycling
                    vec3(0.5, 0.5, 0.5),
                    vec3(0.5, 0.5, 0.5),
                    vec3(1.0, 1.0, 1.0),
                    vec3(0.0, 0.1, 0.2)
                );
                
                // Create lava-like effect by combining palettes
                vec3 color = mix(fire1, fire2, sin(normalized * 20.0 + effectTime) * 0.5 + 0.5);
                
                // Make inside of Mandelbrot set dark with subtle red glow
                if (iteration >= dynamicIterations) {
                    // Enhanced border distance calculation
                    float borderDist = length(z) / (2.0 * zoom);
                    color = vec3(0.2, 0.02, 0.0) * (1.0 - borderDist * 0.2);
                }
                
                // Add orbit trap effect (gives more intricate details)
                float trap = 0.5 + 0.5 * sin(length(orbit) * 14.0 + effectTime * 2.0);
                color = mix(color, vec3(1.0, 0.8, 0.6), trap * 0.1 * (1.0 - normalized));
                
                // Add heat distortion effect around edges
                float edge = smoothstep(0.0, 0.2, normalized) * smoothstep(1.0, 0.8, normalized);
                float distortion = sin(normalized * 30.0 + effectTime * 3.0) * 0.5 + 0.5;
                color = mix(color, vec3(1.0, 0.9, 0.3), edge * distortion * 0.3);
                
                // Apply gamma correction for better visual
                color = pow(color, vec3(0.85));
                
                // Add subtle vignette
                float vignette = 1.0 - length(p * 0.7);
                vignette = smoothstep(0.0, 1.0, vignette);
                color *= vignette * 1.3;
                
                // Add embers effect - small bright dots
                float embers = 0.0;
                for (float i = 0.0; i < 5.0; i++) {
                    float t = effectTime * (0.5 + i * 0.1); // Slower ember movement
                    float x = sin(t * 1.1 + i * 6.0) * 0.7;
                    float y = cos(t * 0.8 + i * 2.0) * 0.7;
                    embers += 0.02 / length(p - vec2(x, y));
                }
                color += vec3(1.0, 0.7, 0.3) * smoothstep(1.5, 6.0, embers) * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 14: Julia Spirals - Deep zoom into dynamic Julia set
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Time progression with reset every 15 seconds
                float time = t * 0.2;
                float effectTime = mod(time, 15.0);
                
                // Controlled zoom with maximum limit
                float zoom = 1.0 + effectTime * 0.5; // Linear zoom instead of exponential
                vec2 center = vec2(0.0, 0.0);
                
                // Transform coordinates
                p = p / zoom + center;
                
                // Julia set parameters with stable rotation
                float cAngle = effectTime * 0.2; // Slower, constant rotation
                float cRadius = 0.7;
                vec2 c = vec2(cos(cAngle), sin(cAngle)) * cRadius;
                
                // Initialize iteration
                vec2 z = p;
                float iterations = 0.0;
                float maxIterations = 100.0;
                
                // Main Julia set loop
                for(float i = 0.0; i < 100.0; i++) {
                    if (i >= maxIterations) break;
                    
                    // z = z^2 + c
                    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                    
                    // Check if point escapes
                    if (length(z) > 2.0) {
                        iterations = i;
                        break;
                    }
                }
                
                // Smooth coloring
                float smooth_iterations = iterations;
                if (iterations < maxIterations) {
                    smooth_iterations = iterations - log2(log2(length(z))) + 4.0;
                }
                
                float normalized = smooth_iterations / maxIterations;
                
                // Create color
                vec3 color = vec3(0.0);
                
                if (iterations < maxIterations) {
                    // Create green/gold/teal palette with stable color cycling
                    float hue = 0.3 + 0.1 * sin(normalized * 20.0 + effectTime * 0.5);
                    float sat = 0.7 + 0.3 * cos(normalized * 5.0 + effectTime * 0.3);
                    float val = 0.6 + 0.4 * normalized;
                    
                    color = hsv2rgb(vec3(hue, sat, val));
                    
                    // Add spiral patterns with stable animation
                    float angle = atan(p.y, p.x);
                    float spiralPattern = sin(angle * 8.0 + length(z) * 15.0 - effectTime);
                    float spiralIntensity = 0.4 + 0.3 * sin(effectTime * 0.3);
                    
                    // Apply spiral highlights
                    color = mix(color, hsv2rgb(vec3(0.4, 0.9, 1.0)), spiralPattern * spiralIntensity * (1.0 - normalized));
                    
                    // Add edge glow
                    float edge = smoothstep(0.0, 0.1, normalized) * smoothstep(1.0, 0.8, normalized);
                    color += hsv2rgb(vec3(0.15, 0.9, 0.9)) * edge * 0.5;
                } else {
                    // Inside Julia set
                    color = vec3(0.05, 0.15, 0.1);
                    
                    // Add subtle details inside with stable animation
                    float detail = length(z) * 10.0;
                    detail = sin(detail * 20.0 + effectTime * 0.5) * 0.5 + 0.5;
                    color = mix(color, vec3(0.0, 0.3, 0.2), detail * 0.3);
                }
                
                // Center highlight
                float centerGlow = 0.15 / (length(p - center) + 0.05);
                color += vec3(0.2, 0.8, 0.5) * centerGlow * 0.3;
                
                // Vignette effect
                float vignette = 1.0 - length(uv * 0.7);
                vignette = smoothstep(0.0, 1.0, vignette);
                color *= vignette * 1.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 16: Psychedelic Swirl - Mind-bending warping patterns
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            // Simple noise function
            float noise(vec2 p) {
                vec2 ip = floor(p);
                vec2 fp = fract(p);
                fp = fp*fp*(3.0-2.0*fp);
                
                vec2 a = vec2(0.0,1.0);
                float r1 = fract(sin(dot(ip, vec2(127.1, 311.7)))*43758.5453123);
                float r2 = fract(sin(dot(ip + a.yx, vec2(127.1, 311.7)))*43758.5453123);
                float r3 = fract(sin(dot(ip + a.xy, vec2(127.1, 311.7)))*43758.5453123);
                float r4 = fract(sin(dot(ip + a.yy, vec2(127.1, 311.7)))*43758.5453123);
                
                return mix(mix(r1, r2, fp.x), mix(r3, r4, fp.x), fp.y);
            }
            
            void main() {
                // Calculate screen coordinates
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Create warping effect with time
                float time = t * 0.5;
                
                // Initial distortion
                p.x += sin(p.y * 4.0 + time) * 0.2;
                p.y += cos(p.x * 4.0 + time * 0.8) * 0.2;
                
                // Create spiral coordinate system
                float angle = atan(p.y, p.x);
                float radius = length(p);
                
                // Apply multiple layers of distortion
                for (int i = 0; i < 5; i++) {
                    float fi = float(i) * 0.5;
                    p.x += sin(p.y * 3.0 + time + fi) * 0.1;
                    p.y += cos(p.x * 5.0 - time * 0.7 + fi) * 0.1;
                }
                
                // Apply noise-based distortion
                float n1 = noise(p * 2.0 + time * 0.1);
                float n2 = noise(p * 4.0 - time * 0.2);
                float n3 = noise(p * 8.0 + time * 0.3);
                
                // Combine noise at different scales
                float n = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
                
                // NEW COLOR SCHEME: Deep purples, neon greens, hot pinks

                // Base color is now more aggressive and vibrant
                // Create base deep purple to hot pink gradient
                float baseMix = fract(angle / (3.14159 * 2.0) + time * 0.2);
                vec3 deepPurple = vec3(0.3, 0.0, 0.5); // Deep purple
                vec3 hotPink = vec3(1.0, 0.0, 0.7);    // Hot pink
                vec3 neonGreen = vec3(0.0, 1.0, 0.2);  // Neon green
                
                // Mix colors based on angle
                vec3 baseColor = mix(deepPurple, hotPink, baseMix);
                baseColor = mix(baseColor, neonGreen, n * 0.7);
                
                // Apply noise modulation to saturation and brightness
                baseColor *= 0.7 + n * 0.8;
                
                // Create strobe-like effect with acid colors
                float strobeEffect = step(0.98, sin(radius * 50.0 - time * 10.0) * 0.5 + 0.5);
                vec3 strobeColor = vec3(0.9, 0.9, 0.1); // Acid yellow
                baseColor = mix(baseColor, strobeColor, strobeEffect * 0.3);
                
                // Fractal rings with complementary colors
                float ringEffect = abs(sin(radius * 20.0 - time * 3.0));
                ringEffect = pow(ringEffect, 3.0);
                baseColor = mix(baseColor, vec3(0.0, 0.8, 1.0), ringEffect * 0.5); // Cyan rings
                
                // Warping waves with neon colors
                float wavePattern = sin(angle * 12.0 + radius * 10.0 - time * 4.0) * 0.5 + 0.5;
                wavePattern = smoothstep(0.4, 0.6, wavePattern);
                baseColor = mix(baseColor, vec3(1.0, 0.3, 0.8), wavePattern * 0.3); // Magenta waves
                
                // Add extreme center glow with alien green
                float centerGlow = 0.1 / (radius + 0.1);
                baseColor += vec3(0.2, 1.0, 0.5) * centerGlow; // Alien green glow
                
                // Add high-contrast edge effects
                float edgeGlow = smoothstep(0.2, 0.4, radius) * smoothstep(1.0, 0.8, radius);
                baseColor = mix(baseColor, vec3(0.9, 0.0, 0.4), edgeGlow * 0.4); // Hot edge glow
                
                // Vignette effect with purple tint
                float vignette = 1.0 - length(uv * 0.5);
                vignette = smoothstep(0.0, 1.0, vignette);
                baseColor *= vignette * 1.2;
                baseColor += vec3(0.2, 0.0, 0.3) * (1.0 - vignette) * 0.2; // Purple vignette
                
                gl_FragColor = vec4(baseColor, 1.0);
            }`         ];

        let musicFiles = [
            'cool.mp3',
            'starwalk.mp3',
            'Fear.mp3',
            'Parallax.mp3',
            'Terra.mp3',
            'The Pression.mp3',
            "nocturnal.flac",
            "space1.mp3",
            "space3.mp3",
            "space4.mp3",
            "space5.mp3",
            "space6.mp3",
            "Voyage.mp3"
        ];
        let currentEffect = 0;
        let currentMusic = 0;
        let isMuted = false;
        let audioContext = null;
        let audioElement = null;
        let playedTracks = new Set();
        let hasStarted = false;

        function startExperience() {
            if (!hasStarted) {
                hasStarted = true;
                document.getElementById('startOverlay').style.display = 'none';
                playNextMusic();
            }
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader error:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexSrc, fragmentSrc) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program error:", gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function getRandomUnplayedTrack() {
            if (playedTracks.size >= musicFiles.length) {
                playedTracks.clear();  // Reset if all tracks have been played
            }
            
            let availableTracks = musicFiles.filter((_, index) => !playedTracks.has(index));
            let randomIndex = Math.floor(Math.random() * availableTracks.length);
            let trackIndex = musicFiles.indexOf(availableTracks[randomIndex]);
            
            playedTracks.add(trackIndex);
            return trackIndex;
        }

        function playNextMusic() {
            if (audioElement) {
                audioElement.pause();
            }
            
            if (musicFiles.length === 0) {
                console.error('No music files available');
                return;
            }
            
            currentMusic = getRandomUnplayedTrack();
            audioElement = new Audio(musicFiles[currentMusic]);
            audioElement.play();
            
            // Update track display
            const trackName = musicFiles[currentMusic].replace('.mp3', '');
            document.getElementById('currentTrack').textContent = `üéµ ${trackName}`;
            
            audioElement.onended = () => {
                playNextMusic();
            };
        }

        function skipTrack() {
            if (audioElement) {
                audioElement.pause();
                playNextMusic();
            }
        }

        function toggleMute() {
            if (audioElement) {
                audioElement.muted = !isMuted;
                isMuted = !isMuted;
                document.getElementById('muteButton').textContent = isMuted ? 'üîá Unmute' : 'üîä Mute';
            }
        }

        function main() {
            const canvas = document.getElementById("glCanvas");
            const gl = canvas.getContext("webgl");
            if (!gl) { 
                console.error("WebGL not supported!");
                alert("WebGL not supported!"); 
                return; 
            }

            // Add error checking for WebGL context
            if (gl.getError() !== gl.NO_ERROR) {
                console.error("WebGL context error:", gl.getError());
            }

            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            
            // Setup audio
            document.getElementById('muteButton').addEventListener('click', toggleMute);
            document.getElementById('skipButton').addEventListener('click', skipTrack);
            document.getElementById('startOverlay').addEventListener('click', startExperience);
            
            // Start playing music only after user interaction
            // playNextMusic(); // Removed from here
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                console.log("Canvas resized to:", canvas.width, "x", canvas.height);
            }
            window.addEventListener("resize", resizeCanvas);
            resizeCanvas();

            let program = createProgram(gl, vertexShaderSrc, shaderEffects[0]);
            if (!program) {
                console.error("Failed to create shader program");
                return;
            }
            gl.useProgram(program);

            const vertices = new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const position = gl.getAttribLocation(program, "position");
            if (position === -1) {
                console.error("Failed to get position attribute location");
                return;
            }
            gl.enableVertexAttribArray(position);
            gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

            const resolution = gl.getUniformLocation(program, "r");
            const time = gl.getUniformLocation(program, "t");
            
            if (resolution === -1 || time === -1) {
                console.error("Failed to get uniform locations");
                return;
            }

            let startTime = performance.now();

            let effectInterval;

            function changeEffect(direction = 1) {
                currentEffect = (currentEffect + direction + shaderEffects.length) % shaderEffects.length;
                program = createProgram(gl, vertexShaderSrc, shaderEffects[currentEffect]);
                gl.useProgram(program);
                
                // Reset time when Mandelbrot effect (Effect #13) or Julia Spirals (Effect #14) is selected
                if (currentEffect === 12 || currentEffect === 13) { // 0-based index for Effect #13 and #14
                    startTime = performance.now();
                    // Clear existing interval
                    if (effectInterval) {
                        clearInterval(effectInterval);
                    }
                    // Set new interval starting from now
                    effectInterval = setInterval(changeEffect, 30000);
                }
                
                // Rebind attributes
                const position = gl.getAttribLocation(program, "position");
                gl.enableVertexAttribArray(position);
                gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
                
                // Update effect number and name
                document.getElementById('effectNumberText').textContent = `${currentEffect + 1}`;
                
                // Get effect name from the shader effects index comments
                const effectNames = [
                    "Flowing Currents",
                    "Cosmic Nebula",
                    "Dynamic Mandala",
                    "Electric Field",
                    "Wave Interference",
                    "Kaleidoscope",
                    "Geometric Flow",
                    "Quantum Flux",
                    "Liquid Crystal",
                    "Aurora Dreams",
                    "Neon Cityscape",
                    "Ocean Depths",
                    "Burning Mandelbrot",
                    "Julia Spirals",
                    "Water Caustics",
                    "Psychedelic Swirl"
                ];
                document.getElementById('effectName').textContent = effectNames[currentEffect];
            }

            // Initial interval setup
            effectInterval = setInterval(changeEffect, 30000);

            // Add keyboard controls
            window.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowRight') {
                    changeEffect(1);
                } else if (event.key === 'ArrowLeft') {
                    changeEffect(-1);
                }
            });

            function render() {
                let now = performance.now();
                let elapsedTime = (now - startTime) / 1000.0;

                // Get current uniform locations
                const resolution = gl.getUniformLocation(program, "r");
                const time = gl.getUniformLocation(program, "t");
                
                // Update uniforms
                gl.uniform2f(resolution, canvas.width, canvas.height);
                gl.uniform1f(time, elapsedTime);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }

            render();
        }

        main();
    </script>
</body>
</html>

