<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shader/370</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #startOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            cursor: pointer;
        }
        #startText {
            color: white;
            font-family: Arial, sans-serif;
            font-size: 24px;
            text-align: center;
            padding: 20px;
            border: 2px solid white;
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        #startText:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: scale(1.05);
        }
        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }
        #copyright {
            position: fixed;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            color: rgba(255, 255, 255, 0.3);
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
        #effectNumber {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            color: rgba(255, 255, 255, 0.3);
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
        }
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        #skipButton {
            background: #2196F3;
        }
        #skipButton:hover {
            background: #1976D2;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="startOverlay">
        <div id="startText">Click anywhere to start the experience</div>
    </div>
    <div id="controls">
        <button id="muteButton">üîä Mute</button>
        <button id="skipButton">‚è≠Ô∏è Skip Track</button>
        <div id="currentTrack" style="margin-top: 5px; font-size: 14px;"></div>
    </div>
    <div id="effectNumber"></div>
    <div id="copyright">(c) hot dog studios</div>
    
    <script>
        // (c) by moshix and hot dog studios
        // shader effect for MVS 3.8 httpd server
        // https://github.com/moshix/mvs38
        // v0.1 humble beginnings
        // 0.2 started adding effects  
        // 0.3 added more effects
        // 0.4 music!
        // 0.5 music controls
        // 0.6 ask user to click something to make music play
        // 0.7 added more effects
        // 0.8 remvoe effect counter
        
        const vertexShaderSrc = `
        attribute vec2 position;
        varying vec2 vUv;
        void main() {
            vUv = position * 0.5 + 0.5;
            gl_Position = vec4(position, 0.0, 1.0);
        }
        `;

        const shaderEffects = [
            // Effect 1: Current flowing pattern
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                float f = cos(a * 3.0) * sin(r * 10.0 - t * 2.0);
                f += sin(p.x * 8.0 + t) * cos(p.y * 8.0 - t);
                f += sin(r * 5.0 - t * 1.5) * cos(a * 2.0);
                
                vec3 hsv = vec3(f * 0.5 + 0.5 + t * 0.1, 0.8, 0.5 + f * 0.5);
                vec3 color = hsv2rgb(hsv);
                
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.5;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 2: New effect - Cosmic Nebula
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create nebula-like effect
                float n = noise(p + t * 0.1);
                float f = sin(r * 10.0 - t * 2.0) * cos(a * 5.0 + t);
                f += sin(p.x * 8.0 + t) * cos(p.y * 8.0 - t);
                f += noise(p * 2.0 + t * 0.2) * 0.5;
                
                // Create multiple layers of color
                vec3 color1 = hsv2rgb(vec3(0.6 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Blue
                vec3 color2 = hsv2rgb(vec3(0.8 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Purple
                vec3 color3 = hsv2rgb(vec3(0.9 + f * 0.2, 0.8, 0.5 + f * 0.5)); // Pink
                
                vec3 color = mix(color1, color2, sin(t * 0.5) * 0.5 + 0.5);
                color = mix(color, color3, cos(t * 0.7) * 0.5 + 0.5);
                
                // Add stars
                float stars = pow(noise(p * 50.0), 20.0);
                color += vec3(1.0) * stars * 0.5;
                
                // Add glow
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 3: New effect - Dynamic Mandala
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float pattern(vec2 p, float scale) {
                float s = scale;
                vec2 q = p * s;
                float d = length(fract(q) - 0.5);
                return smoothstep(0.0, 0.1, d);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create dynamic mandala pattern
                float scale = 8.0;
                float rotation = t * 0.5;
                float petals = 12.0;
                
                // Rotate and scale coordinates
                vec2 q = p;
                float c = cos(rotation), s = sin(rotation);
                q = mat2(c, -s, s, c) * q;
                q *= scale;
                
                // Create base pattern
                float f = pattern(q, 1.0);
                
                // Add petal effect
                float petal = sin(a * petals + r * 10.0 - t * 3.0);
                f += petal * 0.3;
                
                // Add spiral effect
                float spiral = sin(a * 8.0 + r * 15.0 - t * 2.0);
                f += spiral * 0.2;
                
                // Create color based on pattern
                vec3 hsv = vec3(
                    fract(0.5 + f * 0.2 + t * 0.1),  // Magenta to cyan hue
                    0.8,                               // Full saturation
                    0.3 + f * 0.7                     // Value based on pattern
                );
                
                vec3 color = hsv2rgb(hsv);
                
                // Add glow effect
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.8, 0.2, 0.8) * glow * 0.3;
                
                // Add highlights
                float highlight = smoothstep(0.0, 0.1, f);
                color += vec3(1.0) * highlight * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 4: New effect - Electric Field
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Create electric field effect
                float field = 0.0;
                
                // Add multiple electric charges
                for(float i = 0.0; i < 4.0; i++) {
                    float angle = i * 1.5708 + t * 0.5;
                    vec2 charge = vec2(cos(angle), sin(angle)) * 0.5;
                    
                    // Calculate electric field
                    vec2 diff = p - charge;
                    float dist = length(diff);
                    float strength = 1.0 / (dist * dist);
                    
                    // Add field lines
                    float angle2 = atan(diff.y, diff.x);
                    field += sin(angle2 * 20.0 + dist * 30.0 - t * 3.0) * strength;
                }
                
                // Add noise for texture
                float n = noise(p * 5.0 + t * 0.2);
                field += n * 0.2;
                
                // Create color based on field strength
                vec3 hsv = vec3(
                    0.2 + field * 0.1,  // Yellow to green hue
                    0.8,                 // Full saturation
                    0.2 + field * 0.8    // Value based on field strength
                );
                
                vec3 color = hsv2rgb(hsv);
                
                // Add electric arcs
                float arc = smoothstep(0.0, 0.1, abs(field - 0.5));
                color += vec3(1.0, 0.8, 0.0) * arc * 0.5;
                
                // Add glow
                float glow = smoothstep(0.0, 1.0, 1.0 - length(p));
                color += vec3(0.0, 0.8, 0.2) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 5: Wave interference with red theme
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float d1 = length(p - vec2(-0.5, -0.5));
                float d2 = length(p - vec2(0.5, 0.5));
                float d3 = length(p - vec2(0.0, 0.5));
                
                float f = sin(d1 * 15.0 - t * 3.0) + 
                         sin(d2 * 15.0 - t * 3.0 + 2.094) + 
                         sin(d3 * 15.0 - t * 3.0 + 4.188);
                
                // Red and orange theme
                vec3 hsv = vec3(
                    0.0 + f * 0.1,  // Red to orange hue
                    0.8,             // Full saturation
                    0.5 + f * 0.5    // Value varies with pattern
                );
                
                vec3 color = hsv2rgb(hsv);
                color = pow(color, vec3(0.8));
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 6: Kaleidoscope with rainbow theme
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                float segments = 8.0;
                float angle = 2.0 * 3.14159 / segments;
                float segment = floor(a / angle);
                float segmentAngle = mod(a, angle);
                
                float f = sin(segmentAngle * 15.0 + r * 20.0 - t * 3.0);
                f += cos(segment * 3.0 + t * 2.0);
                f += sin(r * 10.0 - t * 1.5);
                
                // Rainbow theme
                vec3 hsv = vec3(
                    fract(segment / segments + t * 0.1),  // Rainbow hue
                    0.8,                                  // Full saturation
                    0.5 + f * 0.5                        // Value varies with pattern
                );
                
                vec3 color = hsv2rgb(hsv);
                
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(1.0, 1.0, 1.0) * glow * 0.3;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // Effect 7: Dynamic Geometric Pattern
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            float pattern(vec2 p, float scale) {
                vec2 q = p * scale;
                float d = length(fract(q) - 0.5);
                return smoothstep(0.0, 0.1, d);
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float a = atan(p.y, p.x);
                float r = length(p);
                
                // Create rotating geometric pattern
                float rotation = t * 0.5;
                float c = cos(rotation), s = sin(rotation);
                vec2 q = mat2(c, -s, s, c) * p;
                
                // Create multiple layers of patterns
                float f = pattern(q, 4.0);
                f += pattern(q * 1.5, 6.0) * 0.5;
                f += pattern(q * 2.0, 8.0) * 0.25;
                
                // Add wave effect
                float wave = sin(a * 8.0 + r * 10.0 - t * 3.0);
                f += wave * 0.2;
                
                // Create smooth color transitions
                vec3 color1 = hsv2rgb(vec3(0.6 + f * 0.2, 0.8, 0.5));  // Blue
                vec3 color2 = hsv2rgb(vec3(0.8 + f * 0.2, 0.8, 0.5));  // Purple
                vec3 color3 = hsv2rgb(vec3(0.9 + f * 0.2, 0.8, 0.5));  // Pink
                
                // Mix colors based on position and time
                vec3 color = mix(color1, color2, sin(t * 0.5) * 0.5 + 0.5);
                color = mix(color, color3, cos(t * 0.7) * 0.5 + 0.5);
                
                // Add glow effect
                float glow = smoothstep(0.0, 1.0, 1.0 - r);
                color += vec3(0.5, 0.3, 0.8) * glow * 0.3;
                
                // Add highlights
                float highlight = smoothstep(0.0, 0.1, f);
                color += vec3(1.0) * highlight * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // New Effect: Quantum Flux - A hypnotic effect with layered, fractal-inspired patterns
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            float fractalnoise(vec2 p) {
                float n = 0.0;
                float amp = 1.0;
                float freq = 1.0;
                
                for(int i = 0; i < 6; i++) {
                    float noise = fract(sin(dot(p * freq, vec2(127.1, 311.7))) * 43758.5453);
                    n += noise * amp;
                    amp *= 0.5;
                    freq *= 2.0;
                }
                
                return n;
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Multiple layers of shifting, rotating patterns
                float time = t * 0.5;
                float rotationSpeed = 0.2;
                float zoomSpeed = 0.15;
                
                // First layer - rotating fractal noise
                float angle1 = time * rotationSpeed;
                float c1 = cos(angle1), s1 = sin(angle1);
                vec2 q1 = mat2(c1, -s1, s1, c1) * p;
                q1 *= 1.0 + sin(time * zoomSpeed) * 0.3;
                float n1 = fractalnoise(q1 * 3.0);
                
                // Second layer - contracting/expanding rings
                float rings = length(p) * 10.0 - time * 2.0;
                rings = abs(mod(rings, 2.0) - 1.0);
                rings = smoothstep(0.5, 0.8, rings);
                
                // Third layer - spiral waves
                float angle2 = atan(p.y, p.x);
                float spiral = sin(angle2 * 8.0 + length(p) * 15.0 - time * 3.0);
                
                // Combine layers with temporal variations
                float blend = sin(time * 0.3) * 0.5 + 0.5;
                float pattern = mix(n1, rings, blend * 0.7);
                pattern = mix(pattern, spiral, (1.0 - blend) * 0.5);
                
                // Create pulsating color gradients
                vec3 color1 = hsv2rgb(vec3(0.7 + time * 0.05, 0.8, 0.6)); // Blue-purple base
                vec3 color2 = hsv2rgb(vec3(0.9 + time * 0.05, 0.9, 0.7)); // Magenta-pink accent
                vec3 color3 = hsv2rgb(vec3(0.5 + time * 0.05, 0.7, 0.8)); // Cyan highlight
                
                // Mix colors based on pattern and oscillating functions
                vec3 color = mix(color1, color2, pattern);
                color = mix(color, color3, spiral * 0.5);
                
                // Add shimmering effect
                float shimmer = fractalnoise(p * 50.0 + time * 0.1);
                color += vec3(1.0) * shimmer * 0.1;
                
                // Vignette effect
                float vignette = 1.0 - length(p * 0.7);
                vignette = smoothstep(0.0, 0.8, vignette);
                color *= vignette * 1.5;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // New Effect: Liquid Crystal - Beautiful fluid-like movement with prismatic colors
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            float hash(vec2 p) {
                float h = dot(p, vec2(127.1, 311.7));
                return fract(sin(h) * 43758.5453123);
            }
            
            // Voronoi/cellular noise function
            vec2 voronoi(vec2 x) {
                vec2 n = floor(x);
                vec2 f = fract(x);
                
                vec2 mg, mr;
                float md = 8.0;
                
                for(int i = -1; i <= 1; i++) {
                    for(int j = -1; j <= 1; j++) {
                        vec2 g = vec2(float(i), float(j));
                        vec2 o = hash(n + g) * 0.5 + 0.5;
                        
                        // Add time-based movement to cell centers
                        o += 0.1 * sin(t * 0.5 + o * 6.28);
                        
                        vec2 r = g + o - f;
                        float d = dot(r, r);
                        
                        if(d < md) {
                            md = d;
                            mr = r;
                            mg = g;
                        }
                    }
                }
                
                return vec2(md, hash(n + mg));
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float time = t * 0.4;
                
                // Create multiple layers of cellular patterns at different scales and speeds
                float scale1 = 4.0 + sin(time * 0.2) * 2.0;
                float scale2 = 8.0 + cos(time * 0.1) * 4.0;
                float scale3 = 16.0;
                
                // Create rotation matrices for each layer
                float a1 = time * 0.1;
                float a2 = time * -0.05;
                mat2 rot1 = mat2(cos(a1), -sin(a1), sin(a1), cos(a1));
                mat2 rot2 = mat2(cos(a2), -sin(a2), sin(a2), cos(a2));
                
                // Generate cellular layers
                vec2 c1 = voronoi(p * scale1 * rot1);
                vec2 c2 = voronoi(p * scale2 * rot2);
                vec2 c3 = voronoi(p * scale3);
                
                // Extract distance and cell ID from Voronoi
                float d1 = c1.x; // Distance to cell edge
                float d2 = c2.x;
                float d3 = c3.x;
                float id1 = c1.y; // Cell ID (random per cell)
                float id2 = c2.y;
                float id3 = c3.y;
                
                // Create cell edges/borders
                float edge1 = 1.0 - smoothstep(0.0, 0.05, d1);
                float edge2 = 1.0 - smoothstep(0.0, 0.05, d2);
                float edge3 = 1.0 - smoothstep(0.0, 0.025, d3);
                
                // Create combined cell pattern
                float cells = edge1 * 0.6 + edge2 * 0.3 + edge3 * 0.1;
                
                // Create cell interior coloring based on cell ID
                float pattern1 = id1;
                float pattern2 = id2;
                float pattern3 = id3 * 0.5;
                
                // Mix patterns with pulsing
                float pattern = mix(pattern1, pattern2, 0.5 + 0.5 * sin(time * 0.3));
                pattern = mix(pattern, pattern3, 0.2 + 0.2 * cos(time * 0.5));
                
                // Create base color from pattern
                vec3 baseColor1 = hsv2rgb(vec3(0.55 + pattern * 0.1, 0.6, 0.6)); // Blue-purple range
                vec3 baseColor2 = hsv2rgb(vec3(0.95 + pattern * 0.1, 0.7, 0.7)); // Pink-red range
                vec3 baseColor = mix(baseColor1, baseColor2, 0.5 + 0.5 * sin(time * 0.2));
                
                // Create cell edge color
                vec3 edgeColor = hsv2rgb(vec3(0.6 + pattern * 0.2, 0.9, 0.9)); // Bright accent color
                
                // Combine cell interior and edges
                vec3 cellColor = mix(baseColor, edgeColor, cells);
                
                // Add dynamic light sources
                vec3 lightColor = vec3(1.0, 0.9, 0.8); // Warm light
                float light = 0.0;
                
                for (float i = 0.0; i < 3.0; i++) {
                    // Light position with circular motion
                    float angle = time * 0.5 + i * 2.09;
                    float radius = 0.5 + 0.3 * sin(time * 0.2 + i);
                    vec2 lightPos = vec2(sin(angle), cos(angle)) * radius;
                    
                    // Light intensity with distance falloff
                    float dist = length(p - lightPos);
                    float intensity = 0.15 / (dist * dist + 0.01);
                    
                    // Add pulsing effect
                    intensity *= 0.8 + 0.2 * sin(time * 2.0 + i * 2.0);
                    
                    light += intensity;
                }
                
                // Add light effect to the cell pattern
                vec3 color = cellColor + lightColor * light;
                
                // Add depth effect with dark areas
                float darkness = smoothstep(0.0, 0.5, length(p));
                color = mix(color, vec3(0.0, 0.02, 0.05), darkness * 0.5);
                
                // Add subtle bloom/glow
                float glow = smoothstep(0.5, 0.0, length(p));
                color += baseColor2 * glow * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // New Effect: Burning Mandelbrot - A fiery take on the classic fractal with warm colors
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            // Palette generator for rich color variation
            vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
                return a + b * cos(6.28318 * (c * t + d));
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                // Time-based animation parameters
                float time = t * 0.1;
                // Reset time for smoother transitions when effect starts
                float effectTime = mod(time, 30.0);
                
                // Mandelbrot position and zoom parameters
                float zoom = 1.8 + 0.5 * sin(effectTime * 0.3);
                vec2 center = vec2(-0.6 + 0.2 * sin(effectTime * 0.2), 0.0 + 0.1 * cos(effectTime * 0.3));
                
                // Rotate the view slightly over time
                float angle = effectTime * 0.1;
                mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                p = rot * p;
                
                // Calculate actual complex plane coordinates
                vec2 c = p / zoom + center;
                
                // Initialize Mandelbrot iteration
                vec2 z = vec2(0.0);
                float iteration = 0.0;
                float maxIterations = 120.0;
                
                // Track the orbit for coloring
                vec2 orbit = vec2(0.0);
                
                // Main Mandelbrot loop
                for (float i = 0.0; i < 120.0; i++) {
                    if (i >= maxIterations) break;
                    
                    // Store last orbit for trap coloring
                    orbit = z;
                    
                    // z = z^2 + c (in complex number math)
                    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
                    
                    // Check if point escapes
                    if (length(z) > 2.0) {
                        iteration = i;
                        break;
                    }
                }
                
                // Create smooth coloring
                float smooth_iteration = iteration;
                if (iteration < maxIterations) {
                    // Standard logarithmic smooth coloring
                    smooth_iteration = iteration + 1.0 - log(log(length(z))) / log(2.0);
                }
                
                // Normalize and adjust for color mapping
                float normalized = smooth_iteration / maxIterations;
                
                // Create a burning color palette (oranges, reds, yellows)
                vec3 fire1 = palette(
                    normalized + effectTime * 0.1,
                    vec3(0.5, 0.5, 0.5),   // brightness
                    vec3(0.5, 0.5, 0.5),   // contrast
                    vec3(1.0, 1.0, 1.0),   // oscillation frequency
                    vec3(0.0, 0.33, 0.67)  // phase shift (creates fire colors)
                );
                
                // Create a second color palette for variation
                vec3 fire2 = palette(
                    normalized + effectTime * 0.05,
                    vec3(0.5, 0.5, 0.5),
                    vec3(0.5, 0.5, 0.5),
                    vec3(1.0, 1.0, 1.0),
                    vec3(0.0, 0.1, 0.2)
                );
                
                // Create lava-like effect by combining palettes
                vec3 color = mix(fire1, fire2, sin(normalized * 20.0 + effectTime) * 0.5 + 0.5);
                
                // Make inside of Mandelbrot set dark with subtle red glow
                if (iteration >= maxIterations) {
                    // Distance to the border - approximation
                    float borderDist = length(z) / 2.0;
                    color = vec3(0.2, 0.02, 0.0) * (1.0 - borderDist * 0.2);
                }
                
                // Add orbit trap effect (gives more intricate details)
                float trap = 0.5 + 0.5 * sin(length(orbit) * 14.0 + effectTime * 2.0);
                color = mix(color, vec3(1.0, 0.8, 0.6), trap * 0.1 * (1.0 - normalized));
                
                // Add heat distortion effect around edges
                float edge = smoothstep(0.0, 0.2, normalized) * smoothstep(1.0, 0.8, normalized);
                float distortion = sin(normalized * 30.0 + effectTime * 3.0) * 0.5 + 0.5;
                color = mix(color, vec3(1.0, 0.9, 0.3), edge * distortion * 0.3);
                
                // Apply gamma correction for better visual
                color = pow(color, vec3(0.85));
                
                // Add subtle vignette
                float vignette = 1.0 - length(p * 0.7);
                vignette = smoothstep(0.0, 1.0, vignette);
                color *= vignette * 1.3;
                
                // Add embers effect - small bright dots
                float embers = 0.0;
                for (float i = 0.0; i < 5.0; i++) {
                    float t = effectTime * (0.5 + i * 0.1);
                    float x = sin(t * 1.1 + i * 3.0) * 0.7;
                    float y = cos(t * 0.8 + i * 1.0) * 0.7;
                    embers += 0.02 / length(p - vec2(x, y));
                }
                color += vec3(1.0, 0.7, 0.3) * smoothstep(1.5, 6.0, embers) * 0.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // New Effect: Julia Spirals - Dynamic Julia set with evolving spiral patterns
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float time = t * 0.3;
                
                // Center and zoom animation
                float zoom = 2.5 + sin(time * 0.1) * 0.5;
                vec2 center = vec2(0.0, 0.0);
                center += vec2(sin(time * 0.2), cos(time * 0.1)) * 0.2;
                
                // Transform coordinates
                p = p / zoom + center;
                
                // Julia set parameters
                float n_value = 2.0 + sin(time * 0.1) * 0.5; // Power varies between 1.5 and 2.5
                
                // Rotating c parameter for Julia set
                float cAngle = time * 0.3;
                float cRadius = 0.7; // Controls the "wildness" of the Julia set
                vec2 c = vec2(cos(cAngle), sin(cAngle)) * cRadius;
                c *= 0.5 + 0.2 * sin(time * 0.2); // Vary the radius too
                
                // Initialize iteration
                vec2 z = p;
                float iterations = 0.0;
                float maxIterations = 100.0;
                
                // For orbit trap coloring
                float minDistance = 1000.0;
                
                // Main Julia set loop
                for(float i = 0.0; i < 100.0; i++) {
                    if (i >= maxIterations) break;
                    
                    // Save current distance for orbit trap
                    float dist = length(z);
                    minDistance = min(minDistance, dist);
                    
                    // If outside escape radius
                    if (dist > 2.0) {
                        iterations = i;
                        break;
                    }
                    
                    // z = z^n + c (using complex number formula)
                    // First get polar form
                    float r = length(z);
                    float theta = atan(z.y, z.x);
                    
                    // Raise to power n
                    r = pow(r, n_value);
                    theta = theta * n_value;
                    
                    // Convert back to cartesian
                    z = vec2(r * cos(theta), r * sin(theta)) + c;
                }
                
                // Smooth coloring formula
                float smooth_iterations = iterations;
                if (iterations < maxIterations) {
                    // Log of base 2 for smooth coloring
                    smooth_iterations = iterations - log2(log2(length(z))) + 4.0;
                }
                
                // Normalize iteration count
                float normalized = smooth_iterations / maxIterations;
                
                // Create base color using green/gold palette
                vec3 color = vec3(0.0);
                
                if (iterations < maxIterations) {
                    // Create green/gold/teal palette
                    float hue = 0.3 + 0.1 * sin(normalized * 20.0 + time); // Green to teal
                    float sat = 0.7 + 0.3 * cos(normalized * 5.0 + time * 0.5); 
                    float val = 0.6 + 0.4 * normalized;
                    
                    color = hsv2rgb(vec3(hue, sat, val));
                    
                    // Add spiral patterns based on angles
                    float angle = atan(p.y, p.x);
                    float spiralPattern = sin(angle * 8.0 + minDistance * 15.0 - time * 2.0);
                    float spiralIntensity = 0.4 + 0.3 * sin(time * 0.5);
                    
                    // Apply spiral highlights
                    color = mix(color, hsv2rgb(vec3(0.4, 0.9, 1.0)), spiralPattern * spiralIntensity * (1.0 - normalized));
                    
                    // Add edge glow
                    float edge = smoothstep(0.0, 0.1, normalized) * smoothstep(1.0, 0.8, normalized);
                    color += hsv2rgb(vec3(0.15, 0.9, 0.9)) * edge * 0.5; // Gold glow
                } else {
                    // Inside Julia set
                    color = vec3(0.05, 0.15, 0.1); // Deep green/blue
                    
                    // Add subtle details inside
                    float detail = minDistance * 10.0;
                    detail = sin(detail * 20.0 + time) * 0.5 + 0.5;
                    color = mix(color, vec3(0.0, 0.3, 0.2), detail * 0.3);
                }
                
                // Center highlight
                float centerGlow = 0.15 / (length(p - center) + 0.05);
                color += vec3(0.2, 0.8, 0.5) * centerGlow * 0.3;
                
                // Vignette effect
                float vignette = 1.0 - length(uv * 0.7);
                vignette = smoothstep(0.0, 1.0, vignette);
                color *= vignette * 1.2;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `,
            // New Effect: Water Caustics - Underwater light refraction patterns
            `
            precision highp float;
            uniform vec2 r;
            uniform float t;
            varying vec2 vUv;
            
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }

            // Random function
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
            }
            
            // Noise function
            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                
                // Four corners in 2D of a tile
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                
                // Smooth interpolation
                vec2 u = f * f * (3.0 - 2.0 * f);
                
                // Mix 4 corners
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            
            void main() {
                vec2 uv = vUv * 2.0 - 1.0;
                vec2 p = uv * vec2(r.x/r.y, 1.0);
                
                float time = t * 0.5;
                
                // Base water color (light blue)
                vec3 waterColor = vec3(0.1, 0.3, 0.5);
                
                // Create caustics effect with multiple overlapping sine waves
                float caustics = 0.0;
                
                // First layer of caustics
                vec2 pos1 = p * 15.0 + vec2(time * 0.7, time * 0.5);
                float c1 = sin(pos1.x) * sin(pos1.y);
                
                // Second layer with different frequency and speed
                vec2 pos2 = p * 12.0 + vec2(-time * 0.5, time * 0.3);
                float c2 = sin(pos2.x) * sin(pos2.y);
                
                // Third layer with more variance
                vec2 pos3 = p * 18.0 + vec2(time * 0.2, -time * 0.6);
                float c3 = sin(pos3.x) * sin(pos3.y);
                
                // Fourth layer for more realistic caustics
                vec2 pos4 = p * 6.0 + vec2(-time * 0.3, -time * 0.4);
                float c4 = sin(pos4.x) * sin(pos4.y);
                
                // Combine all layers
                caustics = c1 * 0.4 + c2 * 0.3 + c3 * 0.2 + c4 * 0.1;
                caustics = pow(caustics * 0.5 + 0.5, 2.0); // Enhance contrast
                
                // Add light variation based on noise
                float noiseVal = noise(p * 2.0 + time * 0.1);
                
                // Create varying light intensity
                float light = caustics * (0.8 + 0.2 * noiseVal);
                
                // Apply color gradient from deep blue to cyan
                vec3 deepColor = vec3(0.0, 0.1, 0.3); // Deep water
                vec3 lightColor = vec3(0.4, 0.7, 1.0); // Light caustics
                
                // Main water color mix
                vec3 color = mix(deepColor, lightColor, light);
                
                // Add subtle shimmer
                float shimmer = noise(p * 50.0 + time * 5.0) * 0.05;
                color += vec3(shimmer);
                
                // Add subtle blue glow in center
                float glow = 0.2 * (1.0 - length(p * 0.5));
                glow = max(0.0, glow);
                color += vec3(0.0, 0.1, 0.3) * glow;
                
                // Add subtle vignette
                float vignette = 1.0 - length(p * 0.7);
                vignette = smoothstep(0.0, 1.0, vignette);
                color *= vignette * 1.1;
                
                gl_FragColor = vec4(color, 1.0);
            }
            `
        ];

        let musicFiles = [
            'cool.mp3',
            'Country_Gentleman.mp3',
            'starwalk.mp3',
            'Fear.mp3',
            'Parallax.mp3',
            'Terra.mp3',
            'The Pression.mp3',
            "nocturnal.flac",
            "space1.mp3",
            "space3.mp3",
            "space4.mp3",
            "space5.mp3",
            "Voyage.mp3"
        ];
        let currentEffect = 0;
        let currentMusic = 0;
        let isMuted = false;
        let audioContext = null;
        let audioElement = null;
        let playedTracks = new Set();
        let hasStarted = false;

        function startExperience() {
            if (!hasStarted) {
                hasStarted = true;
                document.getElementById('startOverlay').style.display = 'none';
                playNextMusic();
            }
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error("Shader error:", gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexSrc, fragmentSrc) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSrc);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program error:", gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function getRandomUnplayedTrack() {
            if (playedTracks.size >= musicFiles.length) {
                playedTracks.clear();  // Reset if all tracks have been played
            }
            
            let availableTracks = musicFiles.filter((_, index) => !playedTracks.has(index));
            let randomIndex = Math.floor(Math.random() * availableTracks.length);
            let trackIndex = musicFiles.indexOf(availableTracks[randomIndex]);
            
            playedTracks.add(trackIndex);
            return trackIndex;
        }

        function playNextMusic() {
            if (audioElement) {
                audioElement.pause();
            }
            
            if (musicFiles.length === 0) {
                console.error('No music files available');
                return;
            }
            
            currentMusic = getRandomUnplayedTrack();
            audioElement = new Audio(musicFiles[currentMusic]);
            audioElement.play();
            
            // Update track display
            const trackName = musicFiles[currentMusic].replace('.mp3', '');
            document.getElementById('currentTrack').textContent = `üéµ ${trackName}`;
            
            audioElement.onended = () => {
                playNextMusic();
            };
        }

        function skipTrack() {
            if (audioElement) {
                audioElement.pause();
                playNextMusic();
            }
        }

        function toggleMute() {
            if (audioElement) {
                audioElement.muted = !isMuted;
                isMuted = !isMuted;
                document.getElementById('muteButton').textContent = isMuted ? 'üîá Unmute' : 'üîä Mute';
            }
        }

        function main() {
            const canvas = document.getElementById("glCanvas");
            const gl = canvas.getContext("webgl");
            if (!gl) { 
                console.error("WebGL not supported!");
                alert("WebGL not supported!"); 
                return; 
            }

            // Add error checking for WebGL context
            if (gl.getError() !== gl.NO_ERROR) {
                console.error("WebGL context error:", gl.getError());
            }

            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            
            // Setup audio
            document.getElementById('muteButton').addEventListener('click', toggleMute);
            document.getElementById('skipButton').addEventListener('click', skipTrack);
            document.getElementById('startOverlay').addEventListener('click', startExperience);
            
            // Start playing music only after user interaction
            // playNextMusic(); // Removed from here
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                console.log("Canvas resized to:", canvas.width, "x", canvas.height);
            }
            window.addEventListener("resize", resizeCanvas);
            resizeCanvas();

            let program = createProgram(gl, vertexShaderSrc, shaderEffects[0]);
            if (!program) {
                console.error("Failed to create shader program");
                return;
            }
            gl.useProgram(program);

            const vertices = new Float32Array([
                -1, -1, 1, -1, -1, 1,
                -1, 1, 1, -1, 1, 1
            ]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const position = gl.getAttribLocation(program, "position");
            if (position === -1) {
                console.error("Failed to get position attribute location");
                return;
            }
            gl.enableVertexAttribArray(position);
            gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

            const resolution = gl.getUniformLocation(program, "r");
            const time = gl.getUniformLocation(program, "t");
            
            if (resolution === -1 || time === -1) {
                console.error("Failed to get uniform locations");
                return;
            }

            let startTime = performance.now();

            function changeEffect(direction = 1) {
                currentEffect = (currentEffect + direction + shaderEffects.length) % shaderEffects.length;
                program = createProgram(gl, vertexShaderSrc, shaderEffects[currentEffect]);
                gl.useProgram(program);
                
                // Rebind attributes
                const position = gl.getAttribLocation(program, "position");
                gl.enableVertexAttribArray(position);
                gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
                
                // Update effect number
                document.getElementById('effectNumber').textContent = `${currentEffect + 1}`;
            }

            // Add keyboard controls
            window.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowRight') {
                    changeEffect(1);
                } else if (event.key === 'ArrowLeft') {
                    changeEffect(-1);
                }
            });

            function render() {
                let now = performance.now();
                let elapsedTime = (now - startTime) / 1000.0;

                // Get current uniform locations
                const resolution = gl.getUniformLocation(program, "r");
                const time = gl.getUniformLocation(program, "t");
                
                // Update uniforms
                gl.uniform2f(resolution, canvas.width, canvas.height);
                gl.uniform1f(time, elapsedTime);

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }

            // Change effect every 30 seconds
            setInterval(changeEffect, 30000);
            
            // Set initial effect number
            document.getElementById('effectNumber').textContent = `${currentEffect + 1}`;
            
            render();
        }

        main();
    </script>
</body>
</html>

